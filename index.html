<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Iron Track</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Firebase SDK (Compat version) -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap");
      body {
        font-family: "Inter", sans-serif;
        background-color: #000;
        color: #ffffff;
        margin: 0;
        overflow: hidden;
        user-select: none;
        touch-action: pan-y;
        -webkit-tap-highlight-color: transparent;
      }
      ::-webkit-scrollbar {
        width: 0px;
        background: transparent;
      }
      input::-webkit-outer-spin-button,
      input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type="number"],
      input[type="text"] {
        -moz-appearance: textfield;
      }
      .safe-area-bottom {
        padding-bottom: env(safe-area-inset-bottom, 20px);
      }
      .fade-in {
        animation: fadeIn 0.4s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .swipe-item-container {
        position: relative;
        overflow: hidden;
        border-radius: 1rem;
        background-color: #000;
        touch-action: pan-y;
      }
      .swipe-action-bg-right {
        position: absolute;
        inset: 0;
        background-color: #000;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        color: #ef4444; 
        font-weight: 900;
        font-size: 0.7rem;
        text-transform: uppercase;
        padding-right: 1.5rem;
        z-index: 1;
      }
      .swipe-action-bg-left {
        position: absolute;
        inset: 0;
        background-color: #000;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        color: #eab308;
        font-weight: 900;
        font-size: 0.7rem;
        text-transform: uppercase;
        padding-left: 1.5rem;
        z-index: 1;
      }
      .swipe-content {
        position: relative;
        z-index: 10;
        background-color: #000000;
        transition: transform 0.15s cubic-bezier(0.2, 0.8, 0.2, 1);
        touch-action: pan-y;
      }
      .modal-overlay {
        background-color: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, memo, useMemo } = React;

      // --- AUDIO HELPER ---
      const playSound = (type) => {
        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) return;
          const ctx = new AudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();

          osc.connect(gain);
          gain.connect(ctx.destination);

          if (type === 'check') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, ctx.currentTime);
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.1, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.1);
          } else if (type === 'timer') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, ctx.currentTime);
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.05, ctx.currentTime + 0.05);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
            gain.gain.linearRampToValueAtTime(0.05, ctx.currentTime + 0.25);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.5);
          }
        } catch (e) {
          console.error("Audio error", e);
        }
      };

      // --- HELPERS ---
      const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      const ICONS = {
        Plus: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`,
        ChevronLeft: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`,
        Check: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`,
        Trash: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`,
        Edit: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`,
        Dumbbell: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="m6.5 6.5 11 11"></path><path d="m18 22 4-4"></path><path d="m2 6 4-4"></path></svg>`,
        Clock: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`,
        X: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`,
        Lock: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry=\"2\"></rect><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"></path></svg>`,
      };

      const Icon = ({ name, size = 24, className = "" }) => {
        const svgFunc = ICONS[name] || ICONS['Dumbbell'];
        return <span className={`inline-flex items-center justify-center ${className}`} dangerouslySetInnerHTML={{ __html: svgFunc(size) }} />;
      };

      const INITIAL_EXERCISES = [
        { id: "ex1", name: "Жим грудь", icon: "Dumbbell", bg: "from-rose-500 to-rose-700" },
        { id: "ex2", name: "Подтягивание", icon: "Dumbbell", bg: "from-emerald-500 to-emerald-700" },
        { id: "ex4", name: "Брусья", icon: "Dumbbell", bg: "from-indigo-500 to-indigo-700" },
        { id: "ex7", name: "Бицепс", icon: "Dumbbell", bg: "from-pink-400 to-pink-600" },
        { id: "ex8", name: "Трицепс", icon: "Dumbbell", bg: "from-cyan-500 to-cyan-700" },
      ];

      // --- UI COMPONENTS ---

      const VolumeChart = ({ history }) => {
        const data = useMemo(() => {
            if (!history || history.length === 0) return [];
            const reversed = [...history].reverse(); 
            return reversed.map(entry => {
                const volume = entry.sets.reduce((acc, set) => {
                    if (set.type === 'set' && set.status === 'done') {
                        const w = parseFloat(set.weight || 0);
                        const r = parseFloat(set.reps || 0);
                        return acc + (w > 0 ? w * r : r); 
                    }
                    return acc;
                }, 0);
                return { date: entry.dateStr, volume: volume };
            }).filter(d => d.volume > 0);
        }, [history]);

        if (data.length < 2) return (
            <div className="h-32 flex items-center justify-center bg-[#111] rounded-3xl border border-gray-900 mb-6">
                <span className="text-[10px] font-bold text-gray-700 uppercase tracking-widest">Нужно больше данных</span>
            </div>
        );

        const height = 130; 
        const width = 300;
        const padding = 20;
        const last = data[data.length - 1];
        const prev = data[data.length - 2];
        const diff = last.volume - prev.volume;
        const diffPct = prev.volume > 0 ? ((diff / prev.volume) * 100).toFixed(1) : 0;
        
        const volumes = data.map(d => d.volume);
        const maxV = Math.max(...volumes);
        const minV = Math.min(...volumes) * 0.95;
        const points = data.map((d, i) => {
            const x = padding + (i / (data.length - 1)) * (width - padding * 2);
            const range = (maxV - minV) || 1;
            const y = height - padding - ((d.volume - minV) / range) * (height - padding * 2);
            return `${x},${y}`;
        }).join(' ');

        return (
            <div className="bg-[#111] p-5 rounded-3xl border border-gray-900 mb-6 shadow-2xl relative overflow-hidden">
                <div className="flex justify-between items-start mb-2">
                  <div>
                    <div className="text-[9px] text-gray-500 font-black uppercase tracking-widest mb-1">Объем сессии</div>
                    <div className="text-xl font-black text-white">{last.volume} кг</div>
                  </div>
                  <div className={`text-[10px] font-black px-2 py-1 rounded-lg ${diff >= 0 ? 'bg-green-500/10 text-green-500' : 'bg-red-500/10 text-red-500'}`}>
                    {diff >= 0 ? '▲' : '▼'} {Math.abs(diffPct)}%
                  </div>
                </div>
                <div className="relative h-[130px] w-full">
                    <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-full overflow-visible">
                        <path d={`${points} L ${width - padding},${height - padding} L ${padding},${height - padding} Z`} fill="url(#chartGrad)" className="opacity-30" />
                        <defs><linearGradient id="chartGrad" x1="0" x2="0" y1="0" y2="1"><stop offset="0%" stopColor="#3b82f6" /><stop offset="100%" stopColor="#3b82f6" stopOpacity="0" /></linearGradient></defs>
                        <polyline fill="none" stroke="#3b82f6" strokeWidth="3" points={points} strokeLinecap="round" strokeLinejoin="round" />
                        {data.map((d, i) => {
                             const x = padding + (i / (data.length - 1)) * (width - padding * 2);
                             const range = (maxV - minV) || 1;
                             const y = height - padding - ((d.volume - minV) / range) * (height - padding * 2);
                             return <circle key={i} cx={x} cy={y} r="3" fill="#000" stroke="#3b82f6" strokeWidth="2" />
                        })}
                        <text x={padding} y={height - 2} fill="#555" fontSize="15" fontWeight="900" textAnchor="start">{data[0].date}</text>
                        <text x={width - padding} y={height - 2} fill="#555" fontSize="15" fontWeight="900" textAnchor="end">{data[data.length-1].date}</text>
                    </svg>
                </div>
            </div>
        );
      };

      const SwipableItem = ({ children, onDelete, onEdit, id, bgClass = "bg-[#111]" }) => {
        const [swipeOffset, setSwipeOffset] = useState(0);
        const startX = useRef(0);
        const isDragging = useRef(false);
        const hasMoved = useRef(false);
        const revealThreshold = 70;
        const autoTriggerThreshold = 180;

        const onPointerDown = (e) => {
          startX.current = e.clientX;
          isDragging.current = true;
          hasMoved.current = false;
        };

        const onPointerMove = (e) => {
          if (!isDragging.current) return;
          const diff = e.clientX - startX.current;
          
          if (!hasMoved.current && Math.abs(diff) > 5) {
            hasMoved.current = true;
            e.currentTarget.setPointerCapture(e.pointerId);
          }
          if (hasMoved.current) {
            const actualDiff = (diff > 0 && !onEdit) ? diff * 0.2 : diff;
            setSwipeOffset(actualDiff);
          }
        };

        const onPointerUp = (e) => {
          if (!isDragging.current) return;
          isDragging.current = false;
          e.currentTarget.releasePointerCapture(e.pointerId);

          if (swipeOffset < -autoTriggerThreshold) {
            onDelete(id);
            setSwipeOffset(0);
          } else if (swipeOffset < -revealThreshold) {
            setSwipeOffset(-revealThreshold - 10);
          } else if (swipeOffset > revealThreshold && onEdit) {
            setSwipeOffset(revealThreshold + 10);
          } else {
            setSwipeOffset(0);
          }
        };

        const handleDeleteClick = (e) => {
          e.stopPropagation();
          onDelete(id);
          setSwipeOffset(0);
        };

        const handleEditClick = (e) => {
          e.stopPropagation();
          if (onEdit) onEdit(id);
          setSwipeOffset(0);
        };

        return (
          <div className="swipe-item-container mb-2">
            <div 
              className={`swipe-action-bg-right transition-opacity ${swipeOffset < 0 ? 'pointer-events-auto opacity-100' : 'pointer-events-none opacity-0'}`} 
              onClick={handleDeleteClick}
            >
              <div className="flex flex-col items-center gap-1">
                <Icon name="Trash" size={20} />
                <span className="text-[9px]">Удалить</span>
              </div>
            </div>
            <div 
              className={`swipe-action-bg-left transition-opacity ${swipeOffset > 0 ? 'pointer-events-auto opacity-100' : 'pointer-events-none opacity-0'}`} 
              onClick={handleEditClick}
            >
              <div className="flex flex-col items-center gap-1">
                <Icon name="Edit" size={20} />
                <span className="text-[9px]">Изменить</span>
              </div>
            </div>
            <div className={`swipe-content rounded-2xl ${bgClass}`} style={{ transform: `translateX(${swipeOffset}px)` }} 
                 onPointerDown={onPointerDown} onPointerMove={onPointerMove} onPointerUp={onPointerUp}>
              {children}
            </div>
          </div>
        );
      };

      // --- VIEWS ---

      const ListView = ({ exercises, history, onSelectHistory, onSelectLog, onAddExercise, onDeleteExercise, onEditExercise }) => {
        const getLastLog = (exId) => history.filter((h) => h.exerciseId === exId)[0] || null;
        return (
          <div className="flex flex-col h-screen bg-black fade-in">
            <div className="p-6 pt-10 flex justify-between items-center bg-black sticky top-0 z-20">
              <h1 className="text-2xl font-black tracking-tight uppercase italic text-white">Iron Track</h1>
              <button onClick={onAddExercise} className="text-white bg-blue-600 p-3 rounded-2xl shadow-xl active:scale-90 transition-transform"><Icon name="Plus" size={24} /></button>
            </div>
            <div className="flex-1 overflow-y-auto px-4 pb-10">
              {exercises.map((ex) => {
                const lastLog = getLastLog(ex.id);
                return (
                  <SwipableItem key={ex.id} id={ex.id} onDelete={onDeleteExercise} onEdit={() => onEditExercise(ex)} bgClass="bg-[#0a0a0a]">
                    <div className="flex items-center py-4 px-3 active:bg-white/5 transition-colors rounded-2xl border border-white/5">
                      <div onClick={() => onSelectHistory(ex)} className={`w-14 h-14 rounded-2xl flex items-center justify-center mr-4 bg-gradient-to-br ${ex.bg || 'from-gray-800 to-black'} shadow-lg cursor-pointer flex-shrink-0`}>
                        <Icon name={ex.icon || "Dumbbell"} size={26} />
                      </div>
                      <div onClick={() => onSelectLog(ex)} className="flex-1 cursor-pointer py-1">
                        <div className="font-black text-[17px] leading-tight text-white mb-1">{ex.name}</div>
                        <div className="text-[10px] text-gray-600 font-black uppercase tracking-widest">
                          {lastLog ? `${lastLog.dateStr} • ${lastLog.sets.filter(s=>s.type==='set').length} сетов` : ''}
                        </div>
                      </div>
                    </div>
                  </SwipableItem>
                );
              })}
            </div>
          </div>
        );
      };

      const ExerciseFormView = ({ onBack, onSave, initialData }) => {
        const [name, setName] = useState(initialData?.name || "");
        return (
          <div className="flex flex-col h-screen bg-black fade-in">
            <div className="p-4 pt-10 flex items-center bg-black border-b border-white/5">
              <div onClick={onBack} className="p-2 cursor-pointer text-blue-500 active:scale-90 transition-transform"><Icon name="ChevronLeft" size={28} /></div>
              <h2 className="flex-1 text-center font-black uppercase italic text-lg">{initialData ? "Настройка" : "Новое"}</h2>
            </div>
            <div className="flex-1 p-8 space-y-4">
              <label className="text-[10px] font-black text-gray-600 uppercase tracking-[0.2em] ml-1">Название упражнения</label>
              <input type="text" className="w-full bg-[#111] border border-gray-800 rounded-2xl p-5 text-white font-black text-xl outline-none focus:border-blue-600 transition-colors" 
                     placeholder="Жим гантелей..." value={name} onChange={(e) => setName(e.target.value)} autoFocus />
            </div>
            <div className="p-6 safe-area-bottom"><button onClick={() => onSave({id: initialData?.id || generateId(), name: name.trim(), icon: "Dumbbell", bg: "from-gray-700 to-black"})} 
                    className="w-full py-5 bg-blue-600 rounded-3xl font-black uppercase italic text-lg shadow-xl active:scale-95 transition-all">Сохранить</button></div>
          </div>
        );
      };

      const DetailView = ({ exercise, history, onBack, onStartLog, onDeleteEntry, onEditEntry }) => {
        const exHistory = useMemo(() => history.filter((h) => h.exerciseId === exercise?.id), [history, exercise]);
        return (
          <div className="flex flex-col h-screen bg-black fade-in">
            <div className="p-4 pt-10 flex items-center bg-black border-b border-white/5 sticky top-0 z-20">
              <div onClick={onBack} className="p-2 cursor-pointer text-blue-500 active:scale-90 transition-transform"><Icon name="ChevronLeft" size={28} /></div>
              <h2 className="flex-1 text-center font-black uppercase italic text-lg truncate px-4">{exercise?.name}</h2>
            </div>
            <div className="flex-1 overflow-y-auto p-4 pb-10">
              <VolumeChart history={exHistory} />
              <h3 className="text-[10px] font-black text-gray-700 uppercase px-1 mb-5 tracking-[0.2em]">История</h3>
              {exHistory.length === 0 ? (
                <div className="text-center py-20 text-gray-800 font-black uppercase text-xs tracking-widest">Пусто</div>
              ) : (
                exHistory.map((item) => (
                  <SwipableItem key={item.id} id={item.id} onDelete={onDeleteEntry} onEdit={() => onEditEntry(item)} bgClass="bg-[#0a0a0a]">
                    <div className="p-5 border border-white/5 rounded-3xl">
                      <div className="flex justify-between items-center mb-4"><span className="font-black text-sm uppercase text-gray-400 tracking-widest">{item.dateStr}</span></div>
                      <div className="space-y-2">
                        {item.sets.filter(s=>s.type==='set').map((s, i) => (
                          <div key={i} className="flex justify-between text-sm bg-white/5 p-2 rounded-xl">
                            <span className="text-gray-600 font-black">#{i+1}</span>
                            <span className="font-black text-gray-200">{s.weight} кг × {s.reps}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  </SwipableItem>
                ))
              )}
            </div>
          </div>
        );
      };

      const RestModal = ({ isOpen, onConfirm, onClose, initialTime }) => {
        const [min, setMin] = useState(Math.floor((initialTime || 180)/60).toString().padStart(2,'0'));
        const [sec, setSec] = useState(((initialTime || 180)%60).toString().padStart(2,'0'));
        useEffect(() => { if(isOpen) { setMin(Math.floor((initialTime || 180)/60).toString().padStart(2,'0')); setSec(((initialTime || 180)%60).toString().padStart(2,'0')); } }, [isOpen, initialTime]);
        if (!isOpen) return null;
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center p-6 modal-overlay fade-in">
            <div className="bg-[#111] w-full max-w-xs rounded-[2.5rem] p-8 border border-white/10 shadow-3xl">
              <h3 className="text-center font-black uppercase tracking-widest text-gray-500 text-[10px] mb-8">Настроить отдых</h3>
              <div className="flex justify-center gap-4 mb-10">
                <input type="number" className="w-20 h-20 bg-black border border-white/10 rounded-3xl text-center text-4xl font-black outline-none focus:border-blue-600" value={min} onChange={e => setMin(e.target.value.slice(0, 2))} />
                <span className="text-4xl font-black text-gray-800 self-center">:</span>
                <input type="number" className="w-20 h-20 bg-black border border-white/10 rounded-3xl text-center text-4xl font-black outline-none focus:border-blue-600" value={sec} onChange={e => setSec(e.target.value.slice(0, 2))} />
              </div>
              <button onClick={() => onConfirm(parseInt(min)*60 + parseInt(sec))} className="w-full py-5 bg-blue-600 rounded-3xl font-black uppercase italic tracking-tight active:scale-95 transition-all">Применить</button>
              <button onClick={onClose} className="w-full py-4 text-gray-600 font-black uppercase text-[10px] tracking-widest mt-2 active:text-white">Отмена</button>
            </div>
          </div>
        );
      };

      const LogView = ({ exercise, sets, onBack, onSave, onUpdateSet, onToggleSet, onAddSet, onAddRestItem, onDeleteSet, onEditRestItem, existingEntry, isSaving }) => {
        const [showRestModal, setShowRestModal] = useState(false);
        const [editingRestIndex, setEditingRestIndex] = useState(null);
        let canNext = true;

        const lastItem = sets.length > 0 ? sets[sets.length - 1] : null;
        const canAddSet = !lastItem || lastItem.type === 'rest';
        const canAddRest = lastItem && lastItem.type === 'set';

        return (
          <div className="flex flex-col h-screen bg-black fade-in">
            <RestModal isOpen={showRestModal} onClose={() => {setShowRestModal(false); setEditingRestIndex(null);}} initialTime={editingRestIndex !== null ? sets.find(s=>s._id===editingRestIndex).duration : null} onConfirm={(t) => { onEditRestItem(editingRestIndex, t); setShowRestModal(false); setEditingRestIndex(null); }} />
            <div className="p-4 pt-10 flex justify-between items-center bg-black border-b border-white/5 sticky top-0 z-20">
              <div onClick={onBack} className="p-2 cursor-pointer text-blue-500 active:scale-90 transition-transform"><Icon name="ChevronLeft" size={28} /></div>
              <div className="text-center flex-1 px-4 overflow-hidden"><h2 className="text-[9px] font-black uppercase text-gray-600 tracking-widest truncate mb-0.5">{exercise?.name}</h2><div className="text-xl font-black tracking-tight uppercase italic text-white">{existingEntry ? 'Правка' : ''}</div></div>
              <button 
                onClick={onSave} 
                disabled={isSaving}
                className={`text-blue-500 font-black text-[14px] uppercase tracking-wide bg-blue-500/10 px-4 py-2 rounded-xl active:bg-blue-500/20 transition-all ${isSaving ? 'opacity-30 pointer-events-none' : ''}`}
              >
                {isSaving ? '...' : 'Готово'}
              </button>
            </div>
            <div className="flex-1 overflow-y-auto p-4 pb-48">
              <div className="grid grid-cols-12 gap-3 text-[9px] font-black text-gray-700 uppercase mb-6 px-2 tracking-widest">
                <div className="col-span-2 text-center">Сет</div>
                <div className="col-span-4 text-center">Вес (кг)</div>
                <div className="col-span-4 text-center">Повт</div>
                <div className="col-span-2"></div>
              </div>
              {sets.map((item, idx) => {
                if (item.type === 'rest') {
                    const elapsedF = `${Math.floor((item.elapsed||0)/60)}:${((item.elapsed||0)%60).toString().padStart(2,'0')}`;
                    const durF = `${Math.floor(item.duration/60)}:${(item.duration%60).toString().padStart(2,'0')}`;
                    return (
                        <SwipableItem key={item._id} id={item._id} onDelete={onDeleteSet} onEdit={() => { setEditingRestIndex(item._id); setShowRestModal(true); }} bgClass="bg-black">
                          <div className={`col-span-12 flex flex-col items-center justify-center py-4 rounded-[1.5rem] border border-dashed transition-all duration-300 ${item.isRunning ? 'border-orange-500 shadow-[0_0_20px_rgba(249,115,22,0.1)]' : 'border-white/10'}`}>
                            <div className={`font-black text-5xl tabular-nums tracking-tighter ${item.isRunning ? 'text-orange-500' : 'text-gray-600'}`}>{elapsedF} <span className="text-2xl text-white/10 mx-1">/</span> {durF}</div>
                          </div>
                        </SwipableItem>
                    );
                }
                const locked = !canNext;
                if (item.status !== 'done') canNext = false;
                const setN = sets.slice(0, idx+1).filter(s=>s.type==='set').length;
                return (
                  <SwipableItem key={item._id} id={item._id} onDelete={onDeleteSet} bgClass="bg-black">
                    <div className={`grid grid-cols-12 gap-3 items-center transition-all duration-300 ${locked ? 'opacity-40' : ''} ${item.status==='done' ? 'opacity-50' : ''}`}>
                      <div className="col-span-2 flex justify-center">
                        <div className={`w-11 h-11 flex items-center justify-center rounded-2xl text-[15px] font-black transition-all ${item.status==='done' ? 'bg-emerald-900/30 text-emerald-500' : 'bg-[#111] text-gray-500'}`}>
                          {setN}
                        </div>
                      </div>
                      <div className="col-span-4"><input type="number" className="w-full bg-[#111] border border-white/5 rounded-2xl p-4 text-center text-xl font-black text-white outline-none focus:border-blue-600 transition-colors" value={item.weight} onChange={(e) => onUpdateSet(idx, 'weight', e.target.value)} /></div>
                      <div className="col-span-4"><input type="number" className="w-full bg-[#111] border border-white/5 rounded-2xl p-4 text-center text-xl font-black text-white outline-none focus:border-blue-600 transition-colors" value={item.reps} onChange={(e) => onUpdateSet(idx, 'reps', e.target.value)} /></div>
                      <div className="col-span-2 flex justify-center"><button onClick={() => !locked && onToggleSet(idx)} className={`w-14 h-14 flex items-center justify-center rounded-2xl transition-all active:scale-90 ${item.status==='done' ? 'bg-emerald-600 shadow-xl shadow-emerald-900/40' : 'bg-[#111] text-gray-700'}`}><Icon name={locked ? "Lock" : "Check"} size={28}/></button></div>
                    </div>
                  </SwipableItem>
                );
              })}
            </div>
            <div className="p-6 safe-area-bottom absolute bottom-0 inset-x-0 bg-gradient-to-t from-black via-black pt-16 flex flex-col gap-4">
              <button onClick={onAddSet} disabled={!canAddSet} 
                      className={`w-full py-5 text-[11px] font-black rounded-3xl border-2 border-dashed uppercase tracking-[0.2em] transition-all duration-300 ${canAddSet ? 'border-white/10 text-gray-400 active:bg-white/5 active:border-white/30' : 'border-transparent text-gray-800 opacity-20'}`}>
                Добавить подход
              </button>
              <button onClick={() => onAddRestItem(180)} disabled={!canAddRest} 
                      className={`w-full py-5 text-[11px] font-black rounded-3xl border-2 border-dashed uppercase tracking-[0.2em] transition-all duration-300 ${canAddRest ? 'border-white/10 text-gray-400 active:bg-white/5 active:border-white/30' : 'border-transparent text-gray-800 opacity-20'}`}>
                Добавить отдых
              </button>
            </div>
          </div>
        );
      };

      // --- MAIN APP ---

      const App = () => {
        const [user, setUser] = useState(null);
        const [view, setView] = useState("list"); 
        const [selectedExercise, setSelectedExercise] = useState(null);
        const [editingExercise, setEditingExercise] = useState(null);
        const [history, setHistory] = useState([]);
        const [customExercises, setCustomExercises] = useState([]);
        const [hiddenExerciseIds, setHiddenExerciseIds] = useState([]);
        const [sets, setSets] = useState([{ _id: generateId(), type: 'set', weight: "", reps: "", status: "empty" }]);
        const [editingHistoryEntryId, setEditingHistoryEntryId] = useState(null);
        const [isSaving, setIsSaving] = useState(false);

        const allExercises = useMemo(() => {
          const base = INITIAL_EXERCISES.map(ie => customExercises.find(ce => ce.id === ie.id) || ie);
          const custom = customExercises.filter(ce => !INITIAL_EXERCISES.find(ie => ie.id === ce.id));
          return [...custom.reverse(), ...base].filter(ex => !hiddenExerciseIds.includes(ex.id));
        }, [customExercises, hiddenExerciseIds]);

        useEffect(() => {
          const init = async () => {
            if (typeof window.firebase !== 'undefined') {
              const config = typeof __firebase_config !== "undefined" ? JSON.parse(__firebase_config) : null;
              if (config && !firebase.apps.length) firebase.initializeApp(config);
              const auth = firebase.auth();
              if (typeof __initial_auth_token !== "undefined" && __initial_auth_token) await auth.signInWithCustomToken(__initial_auth_token).catch(()=>auth.signInAnonymously());
              else await auth.signInAnonymously();
              auth.onAuthStateChanged(u => setUser(u || {uid: 'local'}));
            } else setUser({uid: 'local'});
          };
          init();
        }, []);

        useEffect(() => {
          if (!user) return;
          if (user.uid !== 'local' && window.firebase) {
            const db = firebase.firestore();
            const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
            const unsubH = db.collection(`/artifacts/${aid}/users/${user.uid}/history`).onSnapshot(s => {
                const fetched = s.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setHistory(fetched.length ? fetched.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0)) : []);
            });
            const unsubC = db.collection(`/artifacts/${aid}/users/${user.uid}/exercises`).onSnapshot(s => setCustomExercises(s.docs.map(d => ({ id: d.id, ...d.data() }))));
            const unsubS = db.collection(`/artifacts/${aid}/users/${user.uid}/settings`).doc("hidden").onSnapshot(d => {
              if (d.exists) setHiddenExerciseIds(d.data().ids || []);
            });
            return () => { if(unsubH) unsubH(); if(unsubC) unsubC(); if(unsubS) unsubS(); };
          } else {
            const h = localStorage.getItem("fitness_history");
            setHistory(h ? JSON.parse(h) : []);
            const e = localStorage.getItem("fitness_custom_exercises");
            if (e) setCustomExercises(JSON.parse(e));
            const s = localStorage.getItem("fitness_hidden");
            if (s) setHiddenExerciseIds(JSON.parse(s));
          }
        }, [user]);

        useEffect(() => {
            const timer = setInterval(() => {
                setSets(prev => prev.map(s => {
                  if (s.type === 'rest' && s.isRunning) {
                    const nextElapsed = (s.elapsed || 0) + 1;
                    if (nextElapsed >= s.duration) {
                      playSound('timer');
                      return { ...s, elapsed: s.duration, isRunning: false };
                    }
                    return { ...s, elapsed: nextElapsed };
                  }
                  return s;
                }));
            }, 1000);
            return () => clearInterval(timer);
        }, []);

        const startSession = (ex) => {
            setSelectedExercise(ex);
            setEditingHistoryEntryId(null);
            setIsSaving(false);
            const last = history.find(h => h.exerciseId === ex.id);
            if (last) {
                setSets(last.sets.map(s => ({ ...s, _id: generateId(), status: 'empty', elapsed: 0, isRunning: false })));
            } else {
                setSets([{ _id: generateId(), type: 'set', weight: "", reps: "", status: "empty" }]);
            }
            setView("log");
        };

        const handleSaveWorkout = async () => {
          if (isSaving) return;
          setIsSaving(true);

          const itemsToSave = sets.filter(s => (s.type === 'set' && s.status === 'done') || s.type === 'rest');
          if (!itemsToSave.length) {
            setIsSaving(false);
            return setView("list");
          }

          const now = new Date();
          const entry = { exerciseId: selectedExercise.id, exerciseName: selectedExercise.name, sets: itemsToSave, timestamp: { seconds: Math.floor(now.getTime()/1000) }, dateStr: now.toLocaleDateString("ru-RU", { day: "numeric", month: "short" }) };
          
          try {
            if (user.uid !== 'local' && window.firebase) {
                const db = firebase.firestore();
                const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
                if (editingHistoryEntryId) await db.collection(`/artifacts/${aid}/users/${user.uid}/history`).doc(editingHistoryEntryId).update({ sets: itemsToSave });
                else await db.collection(`/artifacts/${aid}/users/${user.uid}/history`).add(entry);
            } else {
                let updated = editingHistoryEntryId ? history.map(h => h.id === editingHistoryEntryId ? { ...h, sets: itemsToSave } : h) : [{ ...entry, id: generateId() }, ...history];
                setHistory(updated);
                localStorage.setItem("fitness_history", JSON.stringify(updated));
            }
            setView("list");
          } catch (e) {
            console.error(e);
          } finally {
            setIsSaving(false);
            setEditingHistoryEntryId(null);
          }
        };

        const handleActionOnExercise = async (id, action) => {
          if (action === 'delete') {
            const isCustom = customExercises.some(ce => ce.id === id);
            if (isCustom) {
               if (user.uid !== 'local' && window.firebase) {
                  const db = firebase.firestore();
                  const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
                  await db.collection(`/artifacts/${aid}/users/${user.uid}/exercises`).doc(id).delete();
               } else {
                  const updated = customExercises.filter(ce => ce.id !== id);
                  setCustomExercises(updated);
                  localStorage.setItem("fitness_custom_exercises", JSON.stringify(updated));
               }
            } else {
              const newIds = [...hiddenExerciseIds, id];
              setHiddenExerciseIds(newIds);
              if (user.uid !== 'local' && window.firebase) {
                const db = firebase.firestore();
                const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
                await db.collection(`/artifacts/${aid}/users/${user.uid}/settings`).doc("hidden").set({ ids: newIds });
              } else {
                localStorage.setItem("fitness_hidden", JSON.stringify(newIds));
              }
            }
          }
        };

        if (!user) return <div className="h-screen bg-black flex items-center justify-center font-black animate-pulse text-white">IRON TRACK</div>;

        return (
          <div className="max-w-md mx-auto h-screen bg-black border-x border-gray-900 relative overflow-hidden text-white shadow-3xl">
            {view === "list" && <ListView exercises={allExercises} history={history} onSelectHistory={ex => { setSelectedExercise(ex); setView("history"); }} onSelectLog={startSession} onAddExercise={() => { setEditingExercise(null); setView("exercise_form"); }} onDeleteExercise={id => handleActionOnExercise(id, 'delete')} onEditExercise={ex => { setEditingExercise(ex); setView("exercise_form"); }} />}
            {view === "exercise_form" && <ExerciseFormView initialData={editingExercise} onBack={() => setView("list")} onSave={ex => { 
                if (user.uid !== 'local' && window.firebase) {
                   const db = firebase.firestore();
                   const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
                   db.collection(`/artifacts/${aid}/users/${user.uid}/exercises`).doc(ex.id).set(ex);
                } else {
                   const updated = [...customExercises.filter(e=>e.id!==ex.id), ex];
                   setCustomExercises(updated);
                   localStorage.setItem("fitness_custom_exercises", JSON.stringify(updated));
                }
                setView("list"); 
            }} />}
            {view === "history" && <DetailView exercise={selectedExercise} history={history} onBack={() => setView("list")} onStartLog={() => startSession(selectedExercise)} onDeleteEntry={id => { if (user.uid !== 'local' && window.firebase) { const db = firebase.firestore(); const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app"; db.collection(`/artifacts/${aid}/users/${user.uid}/history`).doc(id).delete(); } else { const updated = history.filter(h => h.id !== id); setHistory(updated); localStorage.setItem("fitness_history", JSON.stringify(updated)); } }} onEditEntry={entry => { setEditingHistoryEntryId(entry.id); setSets(entry.sets.map(s => ({ ...s, _id: generateId(), status: s.type==='set' ? 'done' : 'empty' }))); setView("log"); }} />}
            {view === "log" && <LogView exercise={selectedExercise} sets={sets} existingEntry={editingHistoryEntryId} isSaving={isSaving} onBack={() => setView("list")} onSave={handleSaveWorkout} onUpdateSet={(i, f, v) => { const n = [...sets]; n[i][f] = v; setSets(n); }} onToggleSet={i => { 
                const n = [...sets]; 
                const isDone = n[i].status !== 'done'; 
                if (isDone) playSound('check');
                n[i].status = isDone ? 'done' : 'empty'; 
                n.forEach(s => { if(s.type==='rest') s.isRunning = false; }); 
                if(isDone && n[i+1]?.type==='rest') { n[i+1].isRunning = true; n[i+1].elapsed = 0; } 
                setSets(n); 
            }} onAddSet={() => { const lastSet = sets.filter(s=>s.type==='set').slice(-1)[0]; setSets([...sets, { _id: generateId(), type: 'set', weight: lastSet?.weight || "", reps: lastSet?.reps || "", status: "empty" }]); }} onAddRestItem={t => setSets([...sets, { _id: generateId(), type: 'rest', duration: t, elapsed: 0, isRunning: false }])} onDeleteSet={id => setSets(sets.filter((s) => s._id !== id))} onEditRestItem={(id, t) => { setSets(prev => prev.map(s => s._id === id ? { ...s, duration: t } : s)); }} />}
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
