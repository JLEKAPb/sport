<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Iron Track</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Firebase SDK (Compat version) -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap");
      
      :root {
        --bg-main: #000000;
        --bg-card: #111111;
        --bg-card-sec: #0a0a0a;
        --text-main: #ffffff;
        --text-muted: #6b7280; /* gray-500 */
        --border-color: rgba(255, 255, 255, 0.1);
        --input-bg: #111111;
        --chart-line: #3b82f6;
        --chart-text: #555555;
      }

      .theme-light {
        --bg-main: #f3f4f6; /* gray-100 */
        --bg-card: #ffffff;
        --bg-card-sec: #ffffff;
        --text-main: #111827; /* gray-900 */
        --text-muted: #9ca3af; /* gray-400 */
        --border-color: rgba(0, 0, 0, 0.1);
        --input-bg: #f9fafb; /* gray-50 */
        --chart-line: #2563eb;
        --chart-text: #9ca3af;
      }

      body {
        font-family: "Inter", sans-serif;
        background-color: var(--bg-main);
        color: var(--text-main);
        margin: 0;
        overflow: hidden;
        user-select: none;
        touch-action: pan-y;
        -webkit-tap-highlight-color: transparent;
        transition: background-color 0.3s, color 0.3s;
      }
      ::-webkit-scrollbar {
        width: 0px;
        background: transparent;
      }
      input::-webkit-outer-spin-button,
      input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type="number"],
      input[type="text"] {
        -moz-appearance: textfield;
      }
      .safe-area-bottom {
        padding-bottom: env(safe-area-inset-bottom, 20px);
      }
      .fade-in {
        animation: fadeIn 0.4s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .swipe-item-container {
        position: relative;
        overflow: hidden;
        /* border-radius removed to be handled by Tailwind classes */
        background-color: var(--bg-main);
        touch-action: pan-y;
        view-transition-name: var(--vt-name);
        transition: background-color 0.3s;
      }
      .swipe-action-bg-right {
        position: absolute;
        inset: 0;
        background-color: var(--bg-main);
        display: flex;
        align-items: center;
        justify-content: flex-end;
        color: #ef4444; 
        font-weight: 900;
        font-size: 0.7rem;
        text-transform: uppercase;
        padding-right: 1.5rem;
        z-index: 1;
        transition: background-color 0.3s;
      }
      .swipe-action-bg-left {
        position: absolute;
        inset: 0;
        background-color: var(--bg-main);
        display: flex;
        align-items: center;
        justify-content: flex-start;
        color: #eab308;
        font-weight: 900;
        font-size: 0.7rem;
        text-transform: uppercase;
        padding-left: 1.5rem;
        z-index: 1;
        transition: background-color 0.3s;
      }
      .swipe-content {
        position: relative;
        z-index: 10;
        background-color: var(--bg-main);
        transition: transform 0.15s cubic-bezier(0.2, 0.8, 0.2, 1), background-color 0.3s;
        touch-action: pan-y;
      }
      .modal-overlay {
        background-color: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
      }
      .theme-light .modal-overlay {
        background-color: rgba(255, 255, 255, 0.8);
      }
      ::view-transition-group(*) {
        animation-duration: 0.3s;
        animation-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
      }
      
      /* Switch Toggle Styles */
      .switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 28px;
      }
      .switch input { 
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: .4s;
        transition: .4s;
        border-radius: 34px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #2563eb;
      }
      input:focus + .slider {
        box-shadow: 0 0 1px #2563eb;
      }
      input:checked + .slider:before {
        -webkit-transform: translateX(22px);
        -ms-transform: translateX(22px);
        transform: translateX(22px);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, memo, useMemo } = React;

      // --- GLOBAL SOUND FLAG ---
      window.fitness_sound_enabled = true;

      // --- AUDIO HELPER ---
      const playSound = (type) => {
        if (!window.fitness_sound_enabled) return;
        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) return;
          const ctx = new AudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();

          osc.connect(gain);
          gain.connect(ctx.destination);

          if (type === 'check') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, ctx.currentTime);
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.1, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.1);
          } else if (type === 'timer') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, ctx.currentTime);
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.05, ctx.currentTime + 0.05);
            gain.gain.linearRampToValueAtTime(0.05, ctx.currentTime + 0.25);
            gain.gain.linearRampToValueAtTime(0.05, ctx.currentTime + 0.5);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.5);
          }
        } catch (e) {
          console.error("Audio error", e);
        }
      };

      // --- HELPERS ---
      const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      const ICONS = {
        Plus: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`,
        ChevronLeft: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`,
        ChevronUp: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>`,
        ChevronDown: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`,
        Check: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`,
        Trash: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`,
        Edit: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`,
        Dumbbell: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="m6.5 6.5 11 11"></path><path d="m18 22 4-4"></path><path d="m2 6 4-4"></path></svg>`,
        Clock: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`,
        X: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`,
        Lock: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry=\"2\"></rect><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"></path></svg>`,
        Help: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`,
        Settings: (s) => `<svg width="${s}" height="${s}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`,
      };

      const Icon = ({ name, size = 24, className = "" }) => {
        const svgFunc = ICONS[name] || ICONS['Dumbbell'];
        return <span className={`inline-flex items-center justify-center ${className}`} dangerouslySetInnerHTML={{ __html: svgFunc(size) }} />;
      };

      const INITIAL_EXERCISES = [
        { id: "ex1", name: "Жим грудь", icon: "Dumbbell", bg: "from-rose-500 to-rose-700" },
        { id: "ex2", name: "Подтягивание", icon: "Dumbbell", bg: "from-emerald-500 to-emerald-700" },
        { id: "ex4", name: "Брусья", icon: "Dumbbell", bg: "from-indigo-500 to-indigo-700" },
        { id: "ex7", name: "Бицепс", icon: "Dumbbell", bg: "from-pink-400 to-pink-600" },
        { id: "ex8", name: "Трицепс", icon: "Dumbbell", bg: "from-cyan-500 to-cyan-700" },
      ];

      // --- UI COMPONENTS ---

      const SettingsModal = ({ isOpen, onClose, soundEnabled, setSoundEnabled, theme, setTheme }) => {
        if (!isOpen) return null;
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center p-6 modal-overlay fade-in" onClick={onClose}>
            <div className="bg-[var(--bg-card)] w-full max-w-sm rounded-[2rem] p-8 border border-[var(--border-color)] shadow-3xl text-[var(--text-main)]" onClick={e => e.stopPropagation()}>
              <h3 className="text-center font-black uppercase tracking-widest text-[var(--text-muted)] text-xl mb-8">Настройки</h3>
              
              <div className="flex justify-between items-center mb-6">
                <span className="font-bold text-lg">Звук</span>
                <label className="switch">
                  <input type="checkbox" checked={soundEnabled} onChange={(e) => setSoundEnabled(e.target.checked)} />
                  <span className="slider"></span>
                </label>
              </div>

              <div className="flex justify-between items-center mb-8">
                <span className="font-bold text-lg">Светлая тема</span>
                <label className="switch">
                  <input type="checkbox" checked={theme === 'light'} onChange={(e) => setTheme(e.target.checked ? 'light' : 'dark')} />
                  <span className="slider"></span>
                </label>
              </div>

              <button onClick={onClose} className="w-full py-4 bg-blue-600 rounded-2xl text-white font-black uppercase italic tracking-tight active:scale-95 transition-all">Закрыть</button>
            </div>
          </div>
        );
      };

      const HelpModal = ({ isOpen, onClose }) => {
        if (!isOpen) return null;
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center p-6 modal-overlay fade-in" onClick={onClose}>
            <div className="bg-[var(--bg-card)] w-full max-w-sm rounded-[2rem] p-8 border border-[var(--border-color)] shadow-3xl" onClick={e => e.stopPropagation()}>
              <h3 className="text-center font-black uppercase tracking-widest text-[var(--text-muted)] text-xl mb-6">Как пользоваться</h3>
              <ul className="space-y-4 text-sm text-[var(--text-main)] font-bold">
                 <li className="flex gap-3 items-center"><Icon name="Edit" size={16} className="text-yellow-500"/> <span>Свайп вправо — Изменить</span></li>
                 <li className="flex gap-3 items-center"><Icon name="Trash" size={16} className="text-red-500"/> <span>Свайп влево — Удалить</span></li>
                 <li className="flex gap-3 items-center"><Icon name="Dumbbell" size={16} className="text-blue-500"/> <span>Тап по иконке — История</span></li>
                 <li className="flex gap-3 items-center"><Icon name="Plus" size={16} className="text-[var(--text-main)]"/> <span>Тап по названию — Старт</span></li>
                 <li className="flex gap-3 items-center"><Icon name="ChevronUp" size={16} className="text-gray-500"/> <span>Стрелки — Переместить</span></li>
              </ul>
              <button onClick={onClose} className="w-full py-4 bg-blue-600 rounded-2xl text-white font-black uppercase italic tracking-tight mt-8 active:scale-95 transition-all">Понятно</button>
            </div>
          </div>
        );
      };

      const VolumeChart = ({ history, title, subtitle, filterFn }) => {
        const data = useMemo(() => {
            if (!history || history.length === 0) return [];
            const reversed = [...history].reverse(); 
            return reversed.map(entry => {
                const volume = entry.sets.reduce((acc, set) => {
                    if (set.type === 'set' && set.status === 'done') {
                        const w = parseFloat(set.weight || 0);
                        const r = parseFloat(set.reps || 0);
                        
                        if (filterFn && !filterFn(r)) return acc;

                        return acc + (w > 0 ? w * r : r); 
                    }
                    return acc;
                }, 0);
                return { date: entry.dateStr, volume: volume };
            }).filter(d => d.volume > 0);
        }, [history, filterFn]);

        if (data.length < 2) return (
            <div className="h-20 flex items-center justify-center bg-[var(--bg-card)] rounded-none border-b border-[var(--border-color)] mb-0">
                <div className="text-center">
                    <div className="flex items-center justify-center gap-2 mb-0.5">
                      <span className="text-lg text-[var(--text-muted)] font-black uppercase tracking-widest">{title}</span>
                      {subtitle && <span className="text-xs text-gray-500 font-bold">{subtitle}</span>}
                    </div>
                    <span className="text-[10px] font-bold text-[var(--text-muted)] uppercase tracking-widest">Нет данных</span>
                </div>
            </div>
        );

        const height = 90; 
        const width = 300;
        const padding = 10;
        const last = data[data.length - 1];
        const prev = data[data.length - 2];
        const diff = last.volume - prev.volume;
        const diffPct = prev.volume > 0 ? ((diff / prev.volume) * 100).toFixed(1) : 0;
        
        const volumes = data.map(d => d.volume);
        const maxV = Math.max(...volumes);
        const minV = Math.min(...volumes) * 0.95;
        const points = data.map((d, i) => {
            const x = padding + (i / (data.length - 1)) * (width - padding * 2);
            const range = (maxV - minV) || 1;
            const y = height - padding - ((d.volume - minV) / range) * (height - padding * 2);
            return `${x},${y}`;
        }).join(' ');

        return (
            <div className="bg-[var(--bg-card)] p-3 rounded-none border-b border-[var(--border-color)] mb-0 shadow-none relative overflow-hidden">
                <div className="relative flex items-center justify-between mb-1 z-10 h-8">
                  <div className="flex flex-col">
                    <span className="text-lg text-[var(--text-muted)] font-black uppercase tracking-widest">{title}</span>
                    {subtitle && <span className="text-xs text-gray-500 font-bold">{subtitle}</span>}
                  </div>
                  
                  <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                     <div className="text-2xl font-black text-[var(--text-main)] tracking-tighter">{last.volume}<span className="text-[10px] text-gray-600 ml-0.5 font-bold align-top">КГ</span></div>
                  </div>

                  <div className={`text-[9px] font-black px-1.5 py-0.5 rounded-md ${diff >= 0 ? 'bg-green-500/10 text-green-500' : 'bg-red-500/10 text-red-500'}`}>
                    {diff >= 0 ? '▲' : '▼'} {Math.abs(diffPct)}%
                  </div>
                </div>

                <div className="relative h-[90px] w-full">
                    <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-full overflow-visible">
                        {/* Horizontal Grid Lines */}
                        <line x1={padding} y1={height * 0.25} x2={width - padding} y2={height * 0.25} stroke="var(--border-color)" strokeWidth="1" opacity="0.4" />
                        <line x1={padding} y1={height * 0.5} x2={width - padding} y2={height * 0.5} stroke="var(--border-color)" strokeWidth="1" opacity="0.4" />
                        <line x1={padding} y1={height * 0.75} x2={width - padding} y2={height * 0.75} stroke="var(--border-color)" strokeWidth="1" opacity="0.4" />
                        
                        {/* Vertical Grid Lines */}
                        <line x1={width * 0.25} y1={0} x2={width * 0.25} y2={height} stroke="var(--border-color)" strokeWidth="1" opacity="0.4" />
                        <line x1={width * 0.5} y1={0} x2={width * 0.5} y2={height} stroke="var(--border-color)" strokeWidth="1" opacity="0.4" />
                        <line x1={width * 0.75} y1={0} x2={width * 0.75} y2={height} stroke="var(--border-color)" strokeWidth="1" opacity="0.4" />

                        <path d={`${points} L ${width - padding},${height - padding} L ${padding},${height - padding} Z`} fill="url(#chartGrad)" className="opacity-30" />
                        <defs><linearGradient id="chartGrad" x1="0" x2="0" y1="0" y2="1"><stop offset="0%" stopColor="var(--chart-line)" /><stop offset="100%" stopColor="var(--chart-line)" stopOpacity="0" /></linearGradient></defs>
                        <polyline fill="none" stroke="var(--chart-line)" strokeWidth="3" points={points} strokeLinecap="round" strokeLinejoin="round" />
                        {data.map((d, i) => {
                             const x = padding + (i / (data.length - 1)) * (width - padding * 2);
                             const range = (maxV - minV) || 1;
                             const y = height - padding - ((d.volume - minV) / range) * (height - padding * 2);
                             return <circle key={i} cx={x} cy={y} r="3" fill="var(--bg-card)" stroke="var(--chart-line)" strokeWidth="2" />
                        })}
                    </svg>
                </div>
            </div>
        );
      };

      const SwipableItem = ({ children, onDelete, onEdit, id, bgClass = "bg-[var(--bg-card)]", style, compact = false }) => {
        const [swipeOffset, setSwipeOffset] = useState(0);
        const startX = useRef(0);
        const startOffset = useRef(0); 
        const isDragging = useRef(false);
        const hasMoved = useRef(false);
        
        const revealThreshold = 70;
        const maxSwipe = 95; 

        const onPointerDown = (e) => {
          if (e.target.closest('.reorder-btn')) return;
          startX.current = e.clientX;
          startOffset.current = swipeOffset; 
          isDragging.current = true;
          hasMoved.current = false;
        };

        const onPointerMove = (e) => {
          if (!isDragging.current) return;
          const diff = e.clientX - startX.current;
          
          if (!hasMoved.current && Math.abs(diff) > 5) {
            hasMoved.current = true;
            e.currentTarget.setPointerCapture(e.pointerId);
          }
          
          if (hasMoved.current) {
            let val = startOffset.current + diff;
            if (val > 0) { 
              if (!onEdit) val = val * 0.1; 
              else if (val > maxSwipe) val = maxSwipe + (val - maxSwipe) * 0.15; 
            } else { 
              if (val < -maxSwipe) val = -maxSwipe + (val + maxSwipe) * 0.15; 
            }
            setSwipeOffset(val);
          }
        };

        const onPointerUp = (e) => {
          if (!isDragging.current) return;
          isDragging.current = false;
          e.currentTarget.releasePointerCapture(e.pointerId);
          if (swipeOffset < -revealThreshold) {
            setSwipeOffset(-85); 
          } else if (swipeOffset > revealThreshold && onEdit) {
            setSwipeOffset(85); 
          } else {
            setSwipeOffset(0);
          }
        };

        const handleDeleteClick = (e) => {
          e.stopPropagation();
          onDelete(id);
          setSwipeOffset(0);
        };

        const handleEditClick = (e) => {
          e.stopPropagation();
          if (onEdit) onEdit(id);
          setSwipeOffset(0);
        };

        return (
          <div className={`swipe-item-container ${compact ? 'mb-0 rounded-none border-b border-[var(--border-color)]' : 'mb-2 rounded-2xl'}`} style={style}>
            <div 
              className={`swipe-action-bg-right transition-opacity ${swipeOffset < 0 ? 'pointer-events-auto opacity-100' : 'pointer-events-none opacity-0'}`} 
              onClick={handleDeleteClick}
            >
              <div className="flex flex-col items-center gap-1">
                <Icon name="Trash" size={20} />
                <span className="text-[9px]">Удалить</span>
              </div>
            </div>
            <div 
              className={`swipe-action-bg-left transition-opacity ${swipeOffset > 0 ? 'pointer-events-auto opacity-100' : 'pointer-events-none opacity-0'}`} 
              onClick={handleEditClick}
            >
              <div className="flex flex-col items-center gap-1">
                <Icon name="Edit" size={20} />
                <span className="text-[9px]">Изменить</span>
              </div>
            </div>
            <div className={`swipe-content ${compact ? 'rounded-none' : 'rounded-2xl'} ${bgClass}`} style={{ transform: `translateX(${swipeOffset}px)` }} 
                 onPointerDown={onPointerDown} onPointerMove={onPointerMove} onPointerUp={onPointerUp}>
              {children}
            </div>
          </div>
        );
      };

      // --- VIEWS ---

      const ListView = ({ exercises, history, onSelectHistory, onSelectLog, onAddExercise, onDeleteExercise, onEditExercise, onMoveExercise, setSettingsOpen }) => {
        const [showHelp, setShowHelp] = useState(false);
        const getLastLog = (exId) => history.filter((h) => h.exerciseId === exId)[0] || null;
        return (
          <div className="flex flex-col h-screen bg-[var(--bg-main)] fade-in">
            <HelpModal isOpen={showHelp} onClose={() => setShowHelp(false)} />
            <div className="p-6 pt-10 flex justify-between items-center bg-[var(--bg-main)] sticky top-0 z-20">
              <h1 className="text-2xl font-black tracking-tight uppercase italic text-[var(--text-main)]">Iron Track</h1>
              <div className="flex gap-3">
                  <button 
                    onClick={() => setSettingsOpen(true)} 
                    className="text-white bg-gray-700 w-12 h-12 flex items-center justify-center rounded-2xl active:bg-gray-600 transition-colors flex-shrink-0"
                  >
                    <Icon name="Settings" size={24} />
                  </button>
                  <button 
                    onClick={() => setShowHelp(true)} 
                    className="text-white bg-yellow-500 w-12 h-12 flex items-center justify-center rounded-2xl active:bg-yellow-600 transition-colors flex-shrink-0"
                  >
                    <Icon name="Help" size={24} />
                  </button>
                  <button 
                    onClick={onAddExercise} 
                    className="text-white bg-blue-600 w-12 h-12 flex items-center justify-center rounded-2xl shadow-xl active:scale-90 transition-transform flex-shrink-0"
                  >
                    <Icon name="Plus" size={24} />
                  </button>
              </div>
            </div>
            <div className="flex-1 overflow-y-auto px-0 pb-10">
              {exercises.map((ex, idx) => {
                const lastLog = getLastLog(ex.id);
                let lastSetString = "";
                if (lastLog) {
                    const setsOnly = lastLog.sets.filter(s => s.type === 'set');
                    if (setsOnly.length > 0) {
                        const last = setsOnly[setsOnly.length - 1];
                        lastSetString = `: ${last.weight} кг ${last.reps} раз`;
                    }
                }

                return (
                  <SwipableItem key={ex.id} id={ex.id} onDelete={onDeleteExercise} onEdit={() => onEditExercise(ex)} bgClass="bg-[var(--bg-card-sec)]" style={{ "--vt-name": `item-${ex.id}` }} compact={true}>
                    <div className="flex items-center py-1 px-2 active:bg-black/5 transition-colors rounded-none border-b border-[var(--border-color)]">
                      
                      <div onClick={() => onSelectHistory(ex)} className={`w-10 h-10 rounded-xl flex items-center justify-center mr-3 bg-gradient-to-br ${ex.bg || 'from-gray-800 to-black'} shadow-lg cursor-pointer flex-shrink-0`}>
                        <Icon name={ex.icon || "Dumbbell"} size={22} />
                      </div>

                      <div onClick={() => onSelectLog(ex)} className="flex-1 cursor-pointer py-1">
                        <div className="font-black text-[17px] leading-tight text-[var(--text-main)] mb-0.5">
                            {ex.name}
                            {lastSetString && <span className="text-[var(--text-muted)] text-[14px] font-bold">{lastSetString}</span>}
                        </div>
                        <div className="text-[10px] text-gray-500 font-black uppercase tracking-widest">
                          {lastLog ? `${lastLog.dateStr} • ${lastLog.sets.filter(s=>s.type==='set').length} сетов` : ''}
                        </div>
                      </div>

                      <div className="flex flex-col gap-1 ml-3">
                        <button 
                          onClick={(e) => { e.stopPropagation(); onMoveExercise(ex.id, -1); }}
                          disabled={idx === 0}
                          className={`reorder-btn p-1.5 rounded-lg active:bg-white/10 active:scale-90 transition-transform duration-200 ${idx === 0 ? 'opacity-10' : 'opacity-40 hover:opacity-100'}`}
                        >
                          <Icon name="ChevronUp" size={16} />
                        </button>
                        <button 
                          onClick={(e) => { e.stopPropagation(); onMoveExercise(ex.id, 1); }}
                          disabled={idx === exercises.length - 1}
                          className={`reorder-btn p-1.5 rounded-lg active:bg-white/10 active:scale-90 transition-transform duration-200 ${idx === exercises.length - 1 ? 'opacity-10' : 'opacity-40 hover:opacity-100'}`}
                        >
                          <Icon name="ChevronDown" size={16} />
                        </button>
                      </div>
                    </div>
                  </SwipableItem>
                );
              })}
            </div>
          </div>
        );
      };

      const ExerciseFormView = ({ onBack, onSave, initialData }) => {
        const [name, setName] = useState(initialData?.name || "");
        return (
          <div className="flex flex-col h-screen bg-[var(--bg-main)] fade-in">
            <div className="p-4 pt-10 flex items-center bg-[var(--bg-main)] border-b border-[var(--border-color)]">
              <div onClick={onBack} className="p-2 cursor-pointer text-blue-500 active:scale-90 transition-transform"><Icon name="ChevronLeft" size={28} /></div>
              <h2 className="flex-1 text-center font-black uppercase italic text-lg text-[var(--text-main)]">{initialData ? "Настройка" : "Новое"}</h2>
            </div>
            <div className="flex-1 p-8 space-y-4">
              <label className="text-[10px] font-black text-gray-500 uppercase tracking-[0.2em] ml-1">Название упражнения</label>
              <input type="text" className="w-full bg-[var(--input-bg)] border border-[var(--border-color)] rounded-2xl p-5 text-[var(--text-main)] font-black text-xl outline-none focus:border-blue-600 transition-colors" 
                     placeholder="Жим гантелей..." value={name} onChange={(e) => setName(e.target.value)} autoFocus />
            </div>
            <div className="p-6 safe-area-bottom"><button onClick={() => onSave({id: initialData?.id || generateId(), name: name.trim(), icon: "Dumbbell", bg: "from-gray-700 to-black"})} 
                    className="w-full py-5 bg-blue-600 rounded-3xl text-white font-black uppercase italic text-lg shadow-xl active:scale-95 transition-all">Сохранить</button></div>
          </div>
        );
      };

      const DetailView = ({ exercise, history, onBack, onStartLog, onDeleteEntry, onEditEntry }) => {
        const exHistory = useMemo(() => history.filter((h) => h.exerciseId === exercise?.id), [history, exercise]);
        return (
          <div className="flex flex-col h-screen bg-[var(--bg-main)] fade-in">
            <div className="p-4 pt-10 flex items-center bg-[var(--bg-main)] border-b border-[var(--border-color)] sticky top-0 z-20">
              <div onClick={onBack} className="p-2 cursor-pointer text-blue-500 active:scale-90 transition-transform"><Icon name="ChevronLeft" size={28} /></div>
              <h2 className="flex-1 text-center font-black uppercase italic text-lg truncate px-4 text-[var(--text-main)]">{exercise?.name}</h2>
            </div>
            <div className="flex-1 overflow-y-auto pt-4 pb-10 px-0">
              <VolumeChart history={exHistory} title="Силовая" subtitle="< 8 повт." filterFn={r => r < 8} />
              <VolumeChart history={exHistory} title="Обьем" subtitle="≥ 8 повт." filterFn={r => r >= 8} />
              
              {exHistory.length === 0 ? (
                <div className="text-center py-20 text-gray-500 font-black uppercase text-xs tracking-widest">Пусто</div>
              ) : (
                exHistory.map((item) => (
                  <SwipableItem key={item.id} id={item.id} onDelete={onDeleteEntry} onEdit={() => onEditEntry(item)} bgClass="bg-[var(--bg-card-sec)]" compact={true} style={{ marginBottom: '4px' }}>
                    <div className="p-2 border-b border-[var(--border-color)] rounded-none">
                      <div className="space-y-0">
                        {item.sets.filter(s=>s.type==='set').map((s, i) => {
                          const dateStr = s.completedAt ? new Date(s.completedAt).toLocaleString('ru-RU', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' }) : null;
                          return (
                            <div key={i} className="flex justify-between items-center py-1 border-b border-[var(--border-color)] last:border-0">
                              <div className="flex items-center gap-2">
                                  <span className="text-gray-500 font-black text-sm">#{i+1}</span>
                                  {dateStr && <span className="text-xs text-[var(--text-muted)] font-bold">{dateStr}</span>}
                              </div>
                              <div className="text-right">
                                  <span className="font-black text-[var(--text-main)] text-lg">{s.weight} кг × {s.reps}</span>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  </SwipableItem>
                ))
              )}
            </div>
          </div>
        );
      };

      const RestModal = ({ isOpen, onConfirm, onClose, initialTime }) => {
        const [min, setMin] = useState(Math.floor((initialTime || 180)/60).toString().padStart(2,'0'));
        const [sec, setSec] = useState(((initialTime || 180)%60).toString().padStart(2,'0'));
        useEffect(() => { if(isOpen) { setMin(Math.floor((initialTime || 180)/60).toString().padStart(2,'0')); setSec(((initialTime || 180)%60).toString().padStart(2,'0')); } }, [isOpen, initialTime]);
        if (!isOpen) return null;
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center p-6 modal-overlay fade-in">
            <div className="bg-[var(--bg-card)] w-full max-w-xs rounded-[2.5rem] p-8 border border-[var(--border-color)] shadow-3xl">
              <h3 className="text-center font-black uppercase tracking-widest text-gray-500 text-[10px] mb-8">Настроить отдых</h3>
              <div className="flex justify-center gap-4 mb-10">
                <input type="number" className="w-20 h-20 bg-[var(--bg-main)] border border-[var(--border-color)] rounded-3xl text-center text-4xl text-[var(--text-main)] font-black outline-none focus:border-blue-600" value={min} onChange={e => setMin(e.target.value.slice(0, 2))} />
                <span className="text-4xl font-black text-gray-500 self-center">:</span>
                <input type="number" className="w-20 h-20 bg-[var(--bg-main)] border border-[var(--border-color)] rounded-3xl text-center text-4xl text-[var(--text-main)] font-black outline-none focus:border-blue-600" value={sec} onChange={e => setSec(e.target.value.slice(0, 2))} />
              </div>
              <button onClick={() => onConfirm(parseInt(min)*60 + parseInt(sec))} className="w-full py-5 bg-blue-600 rounded-3xl text-white font-black uppercase italic tracking-tight active:scale-95 transition-all">Применить</button>
              <button onClick={onClose} className="w-full py-4 text-gray-500 font-black uppercase text-[10px] tracking-widest mt-2 active:text-[var(--text-main)]">Отмена</button>
            </div>
          </div>
        );
      };

      const LogView = ({ exercise, sets, onBack, onSave, onUpdateSet, onToggleSet, onAddSet, onAddRestItem, onDeleteSet, onEditRestItem, existingEntry, isSaving }) => {
        const [showRestModal, setShowRestModal] = useState(false);
        const [editingRestIndex, setEditingRestIndex] = useState(null);
        let canNext = true;

        const lastItem = sets.length > 0 ? sets[sets.length - 1] : null;
        const canAddSet = !lastItem || lastItem.type === 'rest';
        const canAddRest = lastItem && lastItem.type === 'set';

        return (
          <div className="flex flex-col h-screen bg-[var(--bg-main)] fade-in">
            <RestModal isOpen={showRestModal} onClose={() => {setShowRestModal(false); setEditingRestIndex(null);}} initialTime={editingRestIndex !== null ? sets.find(s=>s._id===editingRestIndex).duration : null} onConfirm={(t) => { onEditRestItem(editingRestIndex, t); setShowRestModal(false); setEditingRestIndex(null); }} />
            <div className="p-4 pt-10 flex justify-between items-center bg-[var(--bg-main)] border-b border-[var(--border-color)] sticky top-0 z-20">
              <div onClick={onBack} className="p-2 cursor-pointer text-blue-500 active:scale-90 transition-transform"><Icon name="ChevronLeft" size={28} /></div>
              <div className="text-center flex-1 px-4 overflow-hidden"><h2 className="text-[9px] font-black uppercase text-gray-500 tracking-widest truncate mb-0.5">{exercise?.name}</h2><div className="text-xl font-black tracking-tight uppercase italic text-[var(--text-main)]">{existingEntry ? 'Правка' : ''}</div></div>
              <button 
                onClick={onSave} 
                disabled={isSaving}
                className={`text-blue-500 font-black text-[14px] uppercase tracking-wide bg-blue-500/10 px-4 py-2 rounded-xl active:bg-blue-500/20 transition-all ${isSaving ? 'opacity-30 pointer-events-none' : ''}`}
              >
                {isSaving ? '...' : 'Готово'}
              </button>
            </div>
            <div className="flex-1 overflow-y-auto p-4 pb-48">
              <div className="grid grid-cols-12 gap-3 text-[9px] font-black text-gray-500 uppercase mb-6 px-2 tracking-widest">
                <div className="col-span-2 text-center">Сет</div>
                <div className="col-span-4 text-center">Вес (кг)</div>
                <div className="col-span-4 text-center">Повт</div>
                <div className="col-span-2"></div>
              </div>
              {sets.map((item, idx) => {
                if (item.type === 'rest') {
                    const elapsedF = `${Math.floor((item.elapsed||0)/60)}:${((item.elapsed||0)%60).toString().padStart(2,'0')}`;
                    const durF = `${Math.floor(item.duration/60)}:${(item.duration%60).toString().padStart(2,'0')}`;
                    return (
                        <SwipableItem key={item._id} id={item._id} onDelete={onDeleteSet} onEdit={() => { setEditingRestIndex(item._id); setShowRestModal(true); }} bgClass="bg-[var(--bg-main)]">
                          <div className={`col-span-12 flex flex-col items-center justify-center py-4 rounded-[1.5rem] border border-dashed transition-all duration-300 ${item.isRunning ? 'border-orange-500 shadow-[0_0_20px_rgba(249,115,22,0.1)]' : 'border-[var(--border-color)]'}`}>
                            <div className={`font-black text-5xl tabular-nums tracking-tighter ${item.isRunning ? 'text-orange-500' : 'text-gray-500'}`}>{elapsedF} <span className="text-2xl text-white/10 mx-1 text-white/10">/</span> {durF}</div>
                          </div>
                        </SwipableItem>
                    );
                }
                const locked = !canNext;
                if (item.status !== 'done') canNext = false;
                const setN = sets.slice(0, idx+1).filter(s=>s.type==='set').length;
                return (
                  <SwipableItem key={item._id} id={item._id} onDelete={onDeleteSet} bgClass="bg-[var(--bg-main)]">
                    <div className={`grid grid-cols-12 gap-3 items-center transition-all duration-300 ${locked ? 'opacity-40' : ''} ${item.status==='done' ? 'opacity-50' : ''}`}>
                      <div className="col-span-2 flex justify-center">
                        <div className={`w-11 h-11 flex items-center justify-center rounded-2xl text-[15px] font-black transition-all ${item.status==='done' ? 'bg-emerald-900/30 text-emerald-500' : 'bg-[var(--bg-card)] text-gray-500'}`}>
                          {setN}
                        </div>
                      </div>
                      <div className="col-span-4"><input type="number" className="w-full bg-[var(--input-bg)] border border-[var(--border-color)] rounded-2xl p-4 text-center text-xl font-black text-[var(--text-main)] outline-none focus:border-blue-600 transition-colors" value={item.weight} onChange={(e) => onUpdateSet(idx, 'weight', e.target.value)} /></div>
                      <div className="col-span-4"><input type="number" className="w-full bg-[var(--input-bg)] border border-[var(--border-color)] rounded-2xl p-4 text-center text-xl font-black text-[var(--text-main)] outline-none focus:border-blue-600 transition-colors" value={item.reps} onChange={(e) => onUpdateSet(idx, 'reps', e.target.value)} /></div>
                      <div className="col-span-2 flex justify-center"><button onClick={() => !locked && onToggleSet(idx)} className={`w-14 h-14 flex items-center justify-center rounded-2xl transition-all active:scale-90 ${item.status==='done' ? 'bg-emerald-600 shadow-xl shadow-emerald-900/40 text-white' : 'bg-[var(--bg-card)] text-gray-500'}`}><Icon name={locked ? "Lock" : "Check"} size={28}/></button></div>
                    </div>
                  </SwipableItem>
                );
              })}
            </div>
            <div className="p-6 safe-area-bottom absolute bottom-0 inset-x-0 bg-gradient-to-t from-[var(--bg-main)] via-[var(--bg-main)] pt-16 flex flex-col gap-4 z-20">
              <button onClick={onAddSet} disabled={!canAddSet} 
                      className={`w-full py-5 text-[11px] font-black rounded-3xl border-2 border-dashed uppercase tracking-[0.2em] transition-all duration-300 ${canAddSet ? 'border-[var(--border-color)] text-gray-400 active:bg-white/5' : 'border-transparent text-gray-500 opacity-20'}`}>
                Добавить подход
              </button>
              <button onClick={() => onAddRestItem(180)} disabled={!canAddRest} 
                      className={`w-full py-5 text-[11px] font-black rounded-3xl border-2 border-dashed uppercase tracking-[0.2em] transition-all duration-300 ${canAddRest ? 'border-[var(--border-color)] text-gray-400 active:bg-white/5' : 'border-transparent text-gray-500 opacity-20'}`}>
                Добавить отдых
              </button>
            </div>
          </div>
        );
      };

      // --- MAIN APP ---

      const App = () => {
        const [user, setUser] = useState(null);
        const [view, setView] = useState("list"); 
        const [selectedExercise, setSelectedExercise] = useState(null);
        const [editingExercise, setEditingExercise] = useState(null);
        const [history, setHistory] = useState([]);
        const [customExercises, setCustomExercises] = useState([]);
        const [hiddenExerciseIds, setHiddenExerciseIds] = useState([]);
        const [exerciseOrder, setExerciseOrder] = useState([]); 
        const [sets, setSets] = useState([{ _id: generateId(), type: 'set', weight: "", reps: "", status: "empty" }]);
        const [editingHistoryEntryId, setEditingHistoryEntryId] = useState(null);
        const [isSaving, setIsSaving] = useState(false);
        const [settingsOpen, setSettingsOpen] = useState(false);
        
        // --- Settings State ---
        const [soundEnabled, setSoundEnabled] = useState(() => {
            try {
                const saved = localStorage.getItem("fitness_sound_enabled");
                return saved !== null ? JSON.parse(saved) : true;
            } catch (e) {
                return true;
            }
        });
        const [theme, setTheme] = useState(() => {
            try {
                return localStorage.getItem("fitness_theme") || "dark";
            } catch (e) {
                return "dark";
            }
        });

        // Sync global sound state
        useEffect(() => {
            window.fitness_sound_enabled = soundEnabled;
            try {
                localStorage.setItem("fitness_sound_enabled", JSON.stringify(soundEnabled));
            } catch (e) {}
        }, [soundEnabled]);

        // Sync theme state
        useEffect(() => {
            if (theme === 'light') document.body.classList.add('theme-light');
            else document.body.classList.remove('theme-light');
            try {
                localStorage.setItem("fitness_theme", theme);
            } catch (e) {}
        }, [theme]);

        const allExercises = useMemo(() => {
          const base = INITIAL_EXERCISES.map(ie => customExercises.find(ce => ce.id === ie.id) || ie);
          const custom = customExercises.filter(ce => !INITIAL_EXERCISES.find(ie => ie.id === ce.id));
          const list = [...custom.reverse(), ...base].filter(ex => !hiddenExerciseIds.includes(ex.id));
          
          if (exerciseOrder.length === 0) return list;
          
          const sorted = [...list].sort((a, b) => {
            const indexA = exerciseOrder.indexOf(a.id);
            const indexB = exerciseOrder.indexOf(b.id);
            if (indexA === -1 && indexB === -1) return 0;
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;
            return indexA - indexB;
          });
          return sorted;
        }, [customExercises, hiddenExerciseIds, exerciseOrder]);

        useEffect(() => {
          const init = async () => {
            // Safety timeout: If Firebase hangs, force local mode after 2 seconds
            const timeoutId = setTimeout(() => {
                setUser(prev => prev || {uid: 'local'});
            }, 2000);

            try {
                if (typeof window.firebase !== 'undefined') {
                    const config = typeof __firebase_config !== "undefined" ? JSON.parse(__firebase_config) : null;
                    if (config) {
                        if (!firebase.apps.length) firebase.initializeApp(config);
                        const auth = firebase.auth();
                        if (typeof __initial_auth_token !== "undefined" && __initial_auth_token) await auth.signInWithCustomToken(__initial_auth_token).catch(()=>auth.signInAnonymously());
                        else await auth.signInAnonymously();
                        auth.onAuthStateChanged(u => {
                            clearTimeout(timeoutId);
                            setUser(u || {uid: 'local'});
                        });
                        return;
                    }
                }
            } catch (e) {
                console.error("Firebase init error, fallback to local", e);
            }
            // Fallback
            clearTimeout(timeoutId);
            setUser({uid: 'local'});
          };
          init();
        }, []);

        useEffect(() => {
          if (!user) return;
          if (user.uid !== 'local' && window.firebase) {
            const db = firebase.firestore();
            const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
            const unsubH = db.collection(`/artifacts/${aid}/users/${user.uid}/history`).onSnapshot(s => {
                const fetched = s.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setHistory(fetched.length ? fetched.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0)) : []);
            });
            const unsubC = db.collection(`/artifacts/${aid}/users/${user.uid}/exercises`).onSnapshot(s => setCustomExercises(s.docs.map(d => ({ id: d.id, ...d.data() }))));
            const unsubS = db.collection(`/artifacts/${aid}/users/${user.uid}/settings`).doc("preferences").onSnapshot(d => {
              if (d.exists) {
                setHiddenExerciseIds(d.data().hiddenIds || []);
                setExerciseOrder(d.data().exerciseOrder || []);
              }
            });
            return () => { if(unsubH) unsubH(); if(unsubC) unsubC(); if(unsubS) unsubS(); };
          } else {
            try {
                const h = localStorage.getItem("fitness_history");
                setHistory(h ? JSON.parse(h) : []);
                const e = localStorage.getItem("fitness_custom_exercises");
                if (e) setCustomExercises(JSON.parse(e));
                const s = localStorage.getItem("fitness_preferences");
                if (s) {
                  const prefs = JSON.parse(s);
                  setHiddenExerciseIds(prefs.hiddenIds || []);
                  setExerciseOrder(prefs.exerciseOrder || []);
                }
            } catch (e) {
                console.warn("Storage access failed", e);
            }
          }
        }, [user]);

        useEffect(() => {
            const timer = setInterval(() => {
                setSets(prev => prev.map(s => {
                  if (s.type === 'rest' && s.isRunning) {
                    const nextElapsed = (s.elapsed || 0) + 1;
                    if (nextElapsed >= s.duration) {
                      playSound('timer');
                      return { ...s, elapsed: s.duration, isRunning: false };
                    }
                    return { ...s, elapsed: nextElapsed };
                  }
                  return s;
                }));
            }, 1000);
            return () => clearInterval(timer);
        }, []);

        const updatePreferences = async (prefs) => {
          if (user.uid !== 'local' && window.firebase) {
            const db = firebase.firestore();
            const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
            await db.collection(`/artifacts/${aid}/users/${user.uid}/settings`).doc("preferences").set(prefs, { merge: true });
          } else {
            try {
                localStorage.setItem("fitness_preferences", JSON.stringify(prefs));
            } catch (e) {}
          }
        };

        const handleMoveExercise = (id, direction) => {
          const currentOrder = exerciseOrder.length > 0 ? [...exerciseOrder] : allExercises.map(e => e.id);
          const index = currentOrder.indexOf(id);
          if (index === -1) return;
          
          const newIndex = index + direction;
          if (newIndex < 0 || newIndex >= currentOrder.length) return;
          
          const update = () => {
             const newOrder = [...currentOrder];
             [newOrder[index], newOrder[newIndex]] = [newOrder[newIndex], newOrder[index]];
             setExerciseOrder(newOrder);
             updatePreferences({ exerciseOrder: newOrder, hiddenIds: hiddenExerciseIds });
          };

          if (document.startViewTransition && window.ReactDOM && ReactDOM.flushSync) {
             document.startViewTransition(() => {
                ReactDOM.flushSync(() => {
                   update();
                });
             });
          } else {
             update();
          }
        };

        const startSession = (ex) => {
            setSelectedExercise(ex);
            setEditingHistoryEntryId(null);
            setIsSaving(false);
            const last = history.find(h => h.exerciseId === ex.id);
            if (last) {
                setSets(last.sets.map(s => ({ ...s, _id: generateId(), status: 'empty', elapsed: 0, isRunning: false })));
            } else {
                setSets([{ _id: generateId(), type: 'set', weight: "", reps: "", status: "empty" }]);
            }
            setView("log");
        };

        const handleSaveWorkout = async () => {
          if (isSaving) return;
          setIsSaving(true);

          const itemsToSave = sets.filter(s => (s.type === 'set' && s.status === 'done') || s.type === 'rest');
          if (!itemsToSave.length) {
            setIsSaving(false);
            return setView("list");
          }

          const now = new Date();
          const entry = { exerciseId: selectedExercise.id, exerciseName: selectedExercise.name, sets: itemsToSave, timestamp: { seconds: Math.floor(now.getTime()/1000) }, dateStr: now.toLocaleDateString("ru-RU", { day: "numeric", month: "short" }) };
          
          try {
            if (user.uid !== 'local' && window.firebase) {
                const db = firebase.firestore();
                const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
                if (editingHistoryEntryId) await db.collection(`/artifacts/${aid}/users/${user.uid}/history`).doc(editingHistoryEntryId).update({ sets: itemsToSave });
                else await db.collection(`/artifacts/${aid}/users/${user.uid}/history`).add(entry);
            } else {
                let updated = editingHistoryEntryId ? history.map(h => h.id === editingHistoryEntryId ? { ...h, sets: itemsToSave } : h) : [{ ...entry, id: generateId() }, ...history];
                setHistory(updated);
                try {
                    localStorage.setItem("fitness_history", JSON.stringify(updated));
                } catch (e) {}
            }
            setView("list");
          } catch (e) {
            console.error(e);
          } finally {
            setIsSaving(false);
            setEditingHistoryEntryId(null);
          }
        };

        const handleActionOnExercise = async (id, action) => {
          if (action === 'delete') {
            const isCustom = customExercises.some(ce => ce.id === id);
            let nextHiddenIds = [...hiddenExerciseIds];
            
            if (isCustom) {
               if (user.uid !== 'local' && window.firebase) {
                  const db = firebase.firestore();
                  const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
                  await db.collection(`/artifacts/${aid}/users/${user.uid}/exercises`).doc(id).delete();
               } else {
                  const updated = customExercises.filter(ce => ce.id !== id);
                  setCustomExercises(updated);
                  try {
                    localStorage.setItem("fitness_custom_exercises", JSON.stringify(updated));
                  } catch (e) {}
               }
            } else {
               if (!nextHiddenIds.includes(id)) {
                 nextHiddenIds.push(id);
                 setHiddenExerciseIds(nextHiddenIds);
               }
            }
            
            const nextOrder = exerciseOrder.filter(oid => oid !== id);
            setExerciseOrder(nextOrder);
            
            updatePreferences({ 
              hiddenIds: nextHiddenIds, 
              exerciseOrder: nextOrder 
            });
          }
        };

        if (!user) return <div className="h-screen bg-black flex items-center justify-center font-black animate-pulse text-white">IRON TRACK</div>;

        return (
          <div className="max-w-md mx-auto h-screen bg-[var(--bg-main)] border-x border-gray-900 relative overflow-hidden text-[var(--text-main)] shadow-3xl">
            <SettingsModal isOpen={settingsOpen} onClose={() => setSettingsOpen(false)} soundEnabled={soundEnabled} setSoundEnabled={setSoundEnabled} theme={theme} setTheme={setTheme} />
            {view === "list" && <ListView exercises={allExercises} history={history} onSelectHistory={ex => { setSelectedExercise(ex); setView("history"); }} onSelectLog={startSession} onAddExercise={() => { setEditingExercise(null); setView("exercise_form"); }} onDeleteExercise={id => handleActionOnExercise(id, 'delete')} onEditExercise={ex => { setEditingExercise(ex); setView("exercise_form"); }} onMoveExercise={handleMoveExercise} setSettingsOpen={setSettingsOpen} />}
            {view === "exercise_form" && <ExerciseFormView initialData={editingExercise} onBack={() => setView("list")} onSave={ex => { 
                if (user.uid !== 'local' && window.firebase) {
                   const db = firebase.firestore();
                   const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app";
                   db.collection(`/artifacts/${aid}/users/${user.uid}/exercises`).doc(ex.id).set(ex);
                } else {
                   const updated = [...customExercises.filter(e=>e.id!==ex.id), ex];
                   setCustomExercises(updated);
                   try {
                        localStorage.setItem("fitness_custom_exercises", JSON.stringify(updated));
                   } catch (e) {}
                }
                if (!exerciseOrder.includes(ex.id)) {
                  const newOrder = [ex.id, ...exerciseOrder];
                  setExerciseOrder(newOrder);
                  updatePreferences({ exerciseOrder: newOrder, hiddenIds: hiddenExerciseIds });
                }
                setView("list"); 
            }} />}
            {view === "history" && <DetailView exercise={selectedExercise} history={history} onBack={() => setView("list")} onStartLog={() => startSession(selectedExercise)} onDeleteEntry={id => { if (user.uid !== 'local' && window.firebase) { const db = firebase.firestore(); const aid = typeof __app_id !== "undefined" ? __app_id : "iron-track-app"; db.collection(`/artifacts/${aid}/users/${user.uid}/history`).doc(id).delete(); } else { const updated = history.filter(h => h.id !== id); setHistory(updated); try { localStorage.setItem("fitness_history", JSON.stringify(updated)); } catch (e) {} } }} onEditEntry={entry => { setEditingHistoryEntryId(entry.id); setSets(entry.sets.map(s => ({ ...s, _id: generateId(), status: s.type==='set' ? 'done' : 'empty' }))); setView("log"); }} />}
            {view === "log" && <LogView exercise={selectedExercise} sets={sets} existingEntry={editingHistoryEntryId} isSaving={isSaving} onBack={() => setView("list")} onSave={handleSaveWorkout} onUpdateSet={(i, f, v) => { const n = [...sets]; n[i][f] = v; setSets(n); }} onToggleSet={i => { 
                const n = [...sets]; 
                const isDone = n[i].status !== 'done'; 
                if (isDone) {
                    playSound('check');
                    n[i].completedAt = new Date().toISOString();
                } else {
                    delete n[i].completedAt;
                }
                n[i].status = isDone ? 'done' : 'empty'; 
                n.forEach(s => { if(s.type==='rest') s.isRunning = false; }); 
                if(isDone && n[i+1]?.type==='rest') { n[i+1].isRunning = true; n[i+1].elapsed = 0; } 
                setSets(n); 
            }} onAddSet={() => { const lastSet = sets.filter(s=>s.type==='set').slice(-1)[0]; setSets([...sets, { _id: generateId(), type: 'set', weight: lastSet?.weight || "", reps: lastSet?.reps || "", status: "empty" }]); }} onAddRestItem={t => setSets([...sets, { _id: generateId(), type: 'rest', duration: t, elapsed: 0, isRunning: false }])} onDeleteSet={id => setSets(sets.filter((s) => s._id !== id))} onEditRestItem={(id, t) => { setSets(prev => prev.map(s => s._id === id ? { ...s, duration: t } : s)); }} />}
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
